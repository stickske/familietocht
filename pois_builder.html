<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>POI Builder from Photos (No libs)</title>
</head>
<body style="font-family:sans-serif; padding:20px;">
  <h1>Build pois.json from photos</h1>
  <input type="file" id="photos" accept="image/jpeg" multiple>
  <button id="downloadBtn" style="display:none;margin-left:10px;">Download pois.json</button>
  <pre id="log" style="background:#222;color:#ccc;padding:10px;white-space:pre-wrap;max-height:240px;overflow:auto;"></pre>
  <pre id="output" style="background:#111;color:#0f0;padding:10px;white-space:pre-wrap;"></pre>

<script>
const log = (...args) => document.getElementById('log').textContent += args.join(' ') + "\n";
let pois = [];

const output = document.getElementById('output');

document.getElementById("photos").addEventListener("change", async (e) => {
  const files = [...e.target.files];
  files.sort((a, b) => a.name.localeCompare(b.name)); //Sort alphabetically - normally standard with file multiple
  pois = [];
  document.getElementById('log').textContent = '';
  output.textContent = '';

  for (const file of files) {
    try {
      const buf = await file.arrayBuffer();
      const view = new DataView(buf);
      const gps = readEXIF_GPS(view);

      if (gps && gps.lat && gps.lon) {
        const img_name = file.name.replace(/\.[^.]+$/, "");

        const index_next = files.indexOf(file) + 1;
        let next_img_name = "";
        if(index_next < files.length)
            next_img_name = files[index_next].name.replace(/\.[^.]+$/, "");

        pois.push({
          img: img_name,
          show: next_img_name,
          lat: gps.lat,
          lon: gps.lon,
          descr: img_name
        });
        log(`✔ ${file.name} → ${gps.lat.toFixed(6)}, ${gps.lon.toFixed(6)}`);
      } else {
        log(`✖ ${file.name} → no GPS found`);
      }
    } catch (err) {
      log(`✖ ${file.name} → error: ${err}`);
    }
  }

  // Make last item's "show" optional or point to itself; here we point to itself
  if (pois.length > 0) {
    pois[pois.length - 1].show = pois[pois.length - 1].img;
  }

  //output.textContent = JSON.stringify(pois, null, 2); //Nice format
  output.textContent = "[\n" + pois.map(poi => "\t"+JSON.stringify(poi)).join(",\n") + "\n]"; //Single line per poi

  document.getElementById("downloadBtn").style.display = pois.length > 0 ? "inline-block" : "none";
});

document.getElementById("downloadBtn").addEventListener("click", () => {
  const blob = new Blob([output.textContent], {type: "application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "pois.json";
  a.click();
  URL.revokeObjectURL(url);
});

// --------- EXIF GPS parsing (handles inline vs offset values) ----------
function readEXIF_GPS(view) {
  // 1) Find APP1 (Exif) segment
  if (view.getUint16(0) !== 0xFFD8) return null; // not a JPEG
  let offset = 2;
  while (offset < view.byteLength) {
    const marker = view.getUint16(offset);
    if ((marker & 0xFFF0) !== 0xFFE0) break; // stop at non-APP marker
    const size = view.getUint16(offset + 2);
    if (marker === 0xFFE1) { // APP1
      const exifHeader = offset + 4;
      if (getAscii(view, exifHeader, 4) === "Exif") {
        const tiff = exifHeader + 6;
        const littleEndian = view.getUint16(tiff) === 0x4949; // "II"
        const firstIFD = view.getUint32(tiff + 4, littleEndian);
        // 2) Parse 0th IFD to find GPS IFD pointer (tag 0x8825)
        const gpsIFDOffset = findGPSIFDOffset(view, tiff, tiff + firstIFD, littleEndian);
        if (!gpsIFDOffset) return null;
        // 3) Parse GPS IFD for tags (1,2,3,4)
        const gps = readGPSIFD(view, tiff, gpsIFDOffset, littleEndian);
        if (gps && gps.GPSLatitude && gps.GPSLongitude) {
          const lat = dmsToDecimal(gps.GPSLatitude, (gps.GPSLatitudeRef || 'N').trim());
          const lon = dmsToDecimal(gps.GPSLongitude, (gps.GPSLongitudeRef || 'E').trim());
          return { lat, lon };
        }
        return null;
      }
    }
    offset += 2 + size;
  }
  return null;
}

function findGPSIFDOffset(view, tiffBase, ifdOffset, le) {
  const entries = view.getUint16(ifdOffset, le);
  for (let i = 0; i < entries; i++) {
    const entry = ifdOffset + 2 + i * 12;
    const tag = view.getUint16(entry, le);
    const type = view.getUint16(entry + 2, le);
    const count = view.getUint32(entry + 4, le);
    const valueOrOffset = view.getUint32(entry + 8, le);

    if (tag === 0x8825) {
      // GPS IFD pointer is a LONG (type=4), so this is an offset from TIFF base
      return tiffBase + valueOrOffset;
    }
  }
  return null;
}

function readGPSIFD(view, tiffBase, gpsIFD, le) {
  const entries = view.getUint16(gpsIFD, le);
  const out = {};
  for (let i = 0; i < entries; i++) {
    const entry = gpsIFD + 2 + i * 12;
    const tag = view.getUint16(entry, le);
    const type = view.getUint16(entry + 2, le);
    const count = view.getUint32(entry + 4, le);
    const valueOrOffset = view.getUint32(entry + 8, le);

    const value = readIFDValue(view, tiffBase, entry, type, count, valueOrOffset, le);

    if (tag === 1) out.GPSLatitudeRef = (value || '').toString();
    if (tag === 2) out.GPSLatitude = value;          // array of 3 rationals
    if (tag === 3) out.GPSLongitudeRef = (value || '').toString();
    if (tag === 4) out.GPSLongitude = value;         // array of 3 rationals
  }
  return out;
}

function readIFDValue(view, tiffBase, entry, type, count, valueOrOffset, le) {
  const typeSize = { 1:1, 2:1, 3:2, 4:4, 5:8, 7:1, 9:4, 10:8 }[type] || 1;
  const byteLen = typeSize * count;

  // If data fits in 4 bytes, it's stored inline at entry+8
  if (byteLen <= 4) {
    if (type === 2) { // ASCII
      return getAscii(view, entry + 8, count).replace(/\0+$/, '');
    }
    if (type === 3) { // SHORT
      return count === 1 ? view.getUint16(entry + 8, le) : readArray(() => view.getUint16, entry + 8, count, 2, le);
    }
    if (type === 4) { // LONG
      return count === 1 ? view.getUint32(entry + 8, le) : readArray(() => view.getUint32, entry + 8, count, 4, le);
    }
    // Fallback: raw bytes
    return new Uint8Array(view.buffer, view.byteOffset + entry + 8, count);
  }

  // Otherwise, valueOrOffset is an *offset* from TIFF base
  const dataOffset = tiffBase + valueOrOffset;

  if (type === 2) { // ASCII
    return getAscii(view, dataOffset, count).replace(/\0+$/, '');
  }
  if (type === 5) { // RATIONAL → return array of numerators/denominators as floats
    const out = [];
    for (let i = 0; i < count; i++) {
      const num = view.getUint32(dataOffset + i*8, le);
      const den = view.getUint32(dataOffset + i*8 + 4, le);
      out.push(den ? (num / den) : 0);
    }
    return out;
  }
  if (type === 3) { // SHORT
    return readArray(() => view.getUint16, dataOffset, count, 2, le);
  }
  if (type === 4) { // LONG
    return readArray(() => view.getUint32, dataOffset, count, 4, le);
  }
  if (type === 7) { // UNDEFINED
    return new Uint8Array(view.buffer, view.byteOffset + dataOffset, count);
  }

  return null;
}

function readArray(getterFactory, offset, count, step, le) {
  const out = [];
  const getter = getterFactory();
  for (let i = 0; i < count; i++) {
    out.push(getter.call(view, offset + i*step, le));
  }
  return out;
}

function getAscii(view, offset, len) {
  let s = '';
  for (let i = 0; i < len; i++) s += String.fromCharCode(view.getUint8(offset + i));
  return s;
}

function dmsToDecimal(dms, ref) {
  if (!Array.isArray(dms) || dms.length < 3) return null;
  let dd = dms[0] + dms[1]/60 + dms[2]/3600;
  if (ref === 'S' || ref === 'W') dd = -dd;
  return dd;
}
</script>

</body>
</html>
